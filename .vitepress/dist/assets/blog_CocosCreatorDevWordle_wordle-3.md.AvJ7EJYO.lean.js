import{_ as n,c as t,a as i,a5 as a,j as s,aw as l,ax as h,ay as p,az as e,aA as k,aB as r,aC as E,aD as d,aE as g,aF as o,aG as y,aH as c,aI as F,aJ as _,aK as m,aL as C,o as b,aM as u,aN as A,aO as B,aP as D,aQ as T,aR as L,aS as f,aT as P,aU as S,aV as N,aW as w,aX as v,aY as I,aZ as x,a_ as R,a$ as V,b0 as O,b1 as X,b2 as q,b3 as M,b4 as U,b5 as H}from"./chunks/framework.C1oSJDt2.js";const ws=JSON.parse('{"title":"cocos creator实现wordle游戏（三）","description":"","frontmatter":{},"headers":[],"relativePath":"blog/CocosCreatorDevWordle/wordle-3.md","filePath":"blog/CocosCreatorDevWordle/wordle-3.md","lastUpdated":1721491738000}'),W={name:"blog/CocosCreatorDevWordle/wordle-3.md"},Y=a("",5),z=s("ul",null,[s("li",null,"top: 宽720，高200（打算放两排组件，第一排是用户头像，第二排是其余功能按钮。一排100像素应该够了）")],-1),G=s("p",{align:"center"},[s("img",{src:l})],-1),Z=s("ul",null,[s("li",null,"bottom:宽720，高400 （一个键盘按钮的高度设计为80，4行按钮差320，算上行间距400应该够了）")],-1),$=s("p",{align:"center"},[s("img",{src:h})],-1),K=s("p",{align:"center"},[s("img",{src:p})],-1),J=s("p",{align:"center"},[s("img",{src:e})],-1),Q=a("",10),j=s("p",{align:"center"},[s("img",{src:k})],-1),ss=s("p",{align:"center"},[s("img",{src:r})],-1),is=s("p",{align:"center"},[s("img",{src:E})],-1),as=s("p",{align:"center"},[s("img",{src:d})],-1),ns=s("ul",null,[s("li",null,"通过Position属性：我们要实现的效果就是，头像显示在左上角，上边距5像素，左边距5像素。具体的属性设置如下")],-1),ts=s("p",{align:"center"},[s("img",{src:g})],-1),ls=s("ul",null,[s("li",null,"通过widget组件： 在head节点上添加widget组件，设置如下：")],-1),hs=s("p",{align:"center"},[s("img",{src:o})],-1),ps=s("p",null,"继续用户昵称 name（类型是Label）的设置，如下：",-1),es=s("p",{align:"center"},[s("img",{src:y})],-1),ks=a("",6),rs=s("p",{align:"center"},[s("img",{src:c})],-1),Es=a("",8),ds=a("",13),gs=s("p",{align:"center"},[s("img",{src:F})],-1),os=a("",5),ys=a("",8),cs=s("ul",null,[s("li",null,"最后我们将Layout_middle1下的btn_middle删除掉，因为我们是通过代码来动态加载这个prefab就不需要在设计期出现了。"),s("li",null,"按照同样的方式制作键盘按钮的prefab，名称为btn_keyborde，制作方式一样就不再累述了。只是大小不一样而已。键盘按钮的大小设置为61 X 80")],-1),Fs=s("h2",{id:"动态加载prefab",tabindex:"-1"},[i("动态加载Prefab "),s("a",{class:"header-anchor",href:"#动态加载prefab","aria-label":'Permalink to "动态加载Prefab"'},"​")],-1),_s=s("p",null,"创建脚本文件：右键点击资源管理器中scripts文件夹，选择“创建”-->“脚本（Typescript）”，命名为home，之所以这样命名是为了和home节点保持一致。然后左键点击层级管理器中的home节点，将home脚本文件拖拽到home节点的属性检查器中，完成脚本文件的挂载，",-1),ms=s("p",{align:"center"},[s("img",{src:_})],-1),Cs=s("p",{align:"center"},[s("img",{src:m})],-1),bs=a("",11),us=a("",4),As=s("p",{align:"center"},[s("img",{src:C})],-1);function Bs(Ds,Ts,Ls,fs,Ps,Ss){return b(),t("div",null,[Y,i(" home，top，midlle，bottom均为空节点并挂载widget组件，它们的widget配置如下： "),z,G,i(" 该配置可保证top始终会展示的屏幕的上方。 "),Z,$,i(" 该配置可以保证bottom始终展示在屏幕的最下方。 设置好这些后，middle的widget组件会默认计算好上下边距： "),K,i(" 修改middle的高度，这两项边距也会发生对应的变化。 对于这款游戏来说，这样的设计思路有点问题。对于Iphone 5这种小屏幕的手机还比较适合，在iphone X,12这样的大屏幕下，顶部，底部和中间的距离就会被拉大，显的不那么紧凑不好看。最终我放弃了这个思路，把中间字母输入的控件和底部按钮控件全塞到了top中。最终如下所示： "),J,i(" top的高宽属性和widget的配置还是保持和上面的一致，这样界面基本上就可以适配绝大部分机型了，但是对于iphone 12这种刘海屏还是有点点问题，后面会在代码中做些处理。 "),Q,i(" 资源管理器中，我已经将需要的图片全都制作好了，如下所示： "),j,i(" 你也可以直接左键选中“headborder”，拖拽到headborder的Sprite Frame属性中。这里还需要再介绍一下.plist文件，在游戏中可以将一类图片打包成plist文件，达到压缩游戏包大小的目的。同时，plist文件可以加载到精灵控件的 SptiteAtlas属性中，后续在代码里面可以很方便的实现图片切换。上图中的btn_keyborde，btn_middle就是plist文件，看字面意思你应该能猜到btn_keyborde就是键盘按钮上的一组图片，btn_middle就是中间字母输入区域，方块显示的背景图了。 "),ss,i(" 点开plist文件就可以看到里面的图片，你也可以直接拖拽其中一个图片到精灵控件的Sprite Frame属性中实现图片的加载。制作plist文件需要用到 Textrue Packer这个软件[官网地址](https://www.codeandweb.com/texturepacker)，虽然是收费的，但是可以免费试用。操作很简单，将需要打包的图片拖拽进去，点击发布精灵表就可以了，唯一需要注意的就是，数据文件和纹理文件是配套的，都需要存放在Texture文件夹下： "),is,i(" 回到头像控件，到现在基本的设置已经完成了，在场景编辑器中就可以设置它的位置了。在层级管理器中左键点击head节点，在场景编辑器中可以看到如下画面： "),as,i(" 但是，我倾向于在属性检查器中来设置它的位置，因为这样更准确。设置它的位置有两种方式，第一种是通过设置Position属性来设置它的位置。第二种是通过widget组件。下面分别来说明这两种方式： "),ns,ts,i(" 这里要先介绍一下锚点，锚点就是节点的原点位置，Position中的x，y的数值都需要根据锚点来计算，可以看到系统默认的锚点是0.5和0.5，表示锚点是位于节点的中间，如果设置为0和0，锚点就会移动到节点的左下方。Position的位置也是相对于父节点的，上图中head的Position设置为X:-305，Y:45。这个是怎么计算出来的呢？head的父节点是top，top的锚点属性也是0.5和0.5，处于top节点的中间位置。top的高度是200，宽度是720，也就是说从锚点向左移动 720 * 0.5 = 360 就到达了top的最左边，这里的到达最左边是指top的子节点head的锚点到达最左边，由于head的锚点处于head的中心，设置X:-360后，head的锚点左边部分就超出了top的范围，也就是只显示了一半。head的宽度是100，一半就是50，所以得再向右移动50才能显示完全，-360 + 50 = -310。由于我们要求左边距为5像素，所以再向右移动5像素 -310 + 5 = -305。同理，head 向上移动 200 * 0.5 = 100，锚点到达top的最上边，但是head锚点上半部分也就超出了top的范围，所以得再向下移动 100 * 0.5 = 50，同时上边距为5，还要再向下移动5，最后100 - 50 - 5 = 45。 "),ls,hs,i(" 可以看出，通过widget组件来设置节点的位置会更简单方便。但是为什么还需要通过锚点和父节点的高宽来计算子节点的位置呢？那是因为并不是所有控件都必须通过widget组件来布局并且如果widget过度使用的话，若果界面出现了布局问题很难查。我的理解是可以通过widget组件布局大体位置，就像最开始我们设计游戏界面分顶部，中间，底部三个部分时，可以通过widget组件将三个部分的位置布局好，然后顶部，中间，底部的内的控件可以通过Position来布局，这样更灵活。掌握这两种布局方法以后，基本上任何布局都可以在属性检查器中来操作，不需要在场景编辑器中用鼠标来拖拽。 "),ps,es,i(" 主要用到的就是上图所示4个地方： "),ks,i(" how用来显示玩法介绍页面，score用来显示玩家得分页面，rank展示世界排名和好友排名，后面两个btn_blank暂时用来占位用的，后面如果注册用户数量达到了可以开通广告。虽然Cocos Creator中支持节点名称相同（它是通过uuid来区分节点的 ），但是建议不要将不同节点命名相同的名称。按钮的设置如下： "),rs,i(" Layout_top设置如下： "),Es,i(" 这里我们在按钮的SpriteAtlas属性中配置了一个plist文件，这个是为了后面在代码中方便切换按钮图标。这个设计的思路是，初始状态下，按钮的SpriteFrame加载的图片btn_top其实只是一个遮罩，罩住按钮节点下的Label，当玩家猜中某得字母时，我们就去掉该遮罩，用于显示按钮节点下的Label的内容，即正确答案。最后将Layout_topright位置配置好就行了，由于Layout_top节点的位置已经配置好，Layout_topright的位置就很好配置了，在Layout_topright的Position属性中，X设置为Layout_top的X值再加上320（Layout_top的宽度是320），Y设置为Layout_top的Y值即可。最终在场景编辑器中效果如下： "),ds,i(" 具体设置不再详述，和中间布局的Layout一样，只是高度变为了80，按钮设计为61 X 80的大小。同样也是再复制另外三个Layout出来。按照同样的方式设置好Position中的Y值，前面三个Layout_bottom放置26个字母按键，设计为通过代码动态加载。在最后一个Layout_bottom4中再创建3个Button（按钮）：“ENTER”，“SPACE”和“DEL”键，设置按钮大小，背景图片（方法在前面已经介绍过了就不再累述），在按钮节点下的Label设置按钮显示的名称，如下： "),gs,i(" 如果一切顺利，在完成上述设置后，最终我们在场景编辑器中的样子是这样的： "),os,i(" 精灵的设置： "),ys,i(" 后续如果需要对prefab做修改，可以双击资源管理器中的prefab，进入prefab的编辑页面进行修改。 "),cs,Fs,_s,ms,i(" 完成挂载以后，可在属性检查器里看到该脚本文件： "),Cs,i(" 如果你已在第一篇教程中完成了环境配置，那么在资源管理器中双击home脚本文件，即可在VS Code中打开。 创建gamemanager。所有代码都写在一个地方，显然不太合适。这里做一下简单的分工，home.ts脚本文件实现一些流程的控制和基本校验，具体的功能，如页面布局，动画显示，得分计算那些我们将它交给gamemanager来实现。以同样方式在scripts文件夹下创建一个gamemanager.ts脚本文件，在gamemanger脚本中我们实现一个gamemanager类来操作游戏相关逻辑，由于它将一个裁判的身份出现，所以设计为单例类。 代码如下： "),bs,i(" 此时，需要将btn_middle，btn_keyborde拖拽到对应的属性下，实现关联。在程序运行时，home节点初始化时便将prefab加载进来了。顺带再介绍一下onLoad，onEnable，start函数，脚本绑定到节点以后，节点在加载的时候，会顺序触发onLoad，onEnable，start函数，onLoad是在节点刚开始加载时触发，onEnale是在节点加载完毕后触发，此时节点下的内容对于用户来说还不可见，start是在节点加载完毕并且状态为active=true后，也就是玩家看到节点中的内容后触发。 "),us,i(" 一切顺利的话，就可以在Chrome里面看到我们的游戏界面了： "),As,i(" 至此，游戏界面就算搭建完成了，接下来就继续实现相关功能了。")])}const vs=n(W,[["render",Bs]]);export{ws as __pageData,vs as default};
